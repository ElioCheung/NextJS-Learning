# 项目结构
> 项目结构：文件作用，名称，作用
```
|-- next-project          // 根目录
  |-- app	                // App Router
  |   |-- layout.tsx          // 页面布局模版
  |   |-- page.tsx            // 页面
  |   |-- loading.tsx         // 加载UI
  |   |-- not-found.tsx       // not found UI
  |   |-- error.tsx           // error UI
  |   |-- global-error.tsx    // global error UI
  |   |-- route.ts            // API endpoint
  |   |-- template.tsx        // Re-rendered layout
  |   |-- default.ts          // Parallel route fallback page
  |   |-- (folderName)        // 路由分组
  |       |-- folderName          // 路由分组
  |   |-- folderName          // 路由名称
  |       |-- [folderName]        // 动态路由
  |       |-- folderName          // 嵌套路由
  |   |-- @folderName         // 命名槽
  |   |-- (.)folderName       // 拦截当层路由
  |   |-- (..)folderName      // 拦截上一层路由
  |   |-- (..)(..)folderName  // 拦截上两层路由
  |   |-- (...)folderName     // 拦截根路由
  |-- pages	              // Page Router
  |-- public	            // 静态资源，例如：图片、字体等
  |-- next.config.js      // NextJS配置文件
  |-- middleware.ts       // 中间件
  |-- .env                // 环境变量
  |-- .env.local          // 本地环境变量
  |-- .env.development    // 开发环境变量
  |-- .env.production     // 生产环境变量
  |-- next-env.d.ts       // NextJS的ts声明文件

```

# 开始学习路途
> 根据官方文档指引，初学者学习路径：路由（Routing）-》渲染（Rendering）-》数据获取（Data Fetching）-》样式（Styling）。之后，进一步深入学习：优化（Optimizing）和配置（Configuring）。

## 路由（Routing）

### 术语
1. Tree：用于可视化层次结构的约定
2. Subtree：Tree的一部分
3. Root：Tree或者Subtree的第一个节点
4. Leaf：Subtree中没有子节点的节点
5. URL Segment：URL 路径的一部分，由斜杠分隔
6. URL Path：域名后面的 URL 部分（由URL Segment组成）

### app
NextJS使用基于「文件系统」的路由：
  - __文件夹__： 用于定义路由，以及嵌套路由
  - __文件__：用于创建与路由匹配的相关UI

文件夹中仅有 page.tsx 或 route.tsx 返回的内容是可公开寻址的。因此，还可以放置其他文件，例如：Components、Styling、Testing等。

1. page.tsx

用于展示当前路径下的页面UI：
- page.tsx始终是子路由树的叶子节点;
- 确保路由能被访问，路由文件夹下必须含有此文件；
- 在此文件中，可「获取数据」

2. layout.tsx

布局：在多个页面中的公共UI。在导航时，布局保留状态、保持交互性且不会重新渲染。同时，布局也是可以嵌套的。
- 位于最顶层的layout，我们称之为「Root Layout」。它为所有路由所共享，且由于是根布局，其必须包含html和body标签；
- 每个路由均可有其自己的布局，且共享其他子路由；
- 此文件中，可「获取数据」；
- 无法在父子布局间「传递数据」。但是，可以在一个路由中多次获取相同的数据，React 会自动删除请求的重复数据，而不会影响性能；
- 布局无法访问当前的route segment。但，可在*客户端组件*中使用「useSelectedLayoutSegments」或「useSelectedLayoutSegment」获取。

3. template.tsx

模版与布局类似，包裹每个子布局和页面。与布局不同的是，在导航时，为每个子项创建新的实例。这意味着当用户在共享模板的路由之间导航时，新的实例被挂载时，会重新创建 DOM 元素，不保留状态，并且重新同步效果。

什么场景适合使用模版呢？
- 依赖 useEffect（例如： logging page views）和 useState（例如：a per-page feedback form）的功能；
- 更改默认框架的行为

模版嵌套于布局与子布局之间。
在同一路由中，渲染的顺序：layout -》 template -》 page。

4. 修改‘head’

在page或layout中，使用内置的SEO，修改title和meta属性。

```
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'NextJS Demo',
  description: 'Generated by create next app',
}
...
```

### Linking and Navigating

> 切换路由方法：
  - ```<Link />```
  - useRouter

1. Link组件
Link是NextJS内置组件，扩展自HTML的a标签。
```
import Link from 'next/link';

export default function Home() {
  return (
    <main className='flex min-h-screen flex-col items-center justify-between p-24'>
      <h1 className='text-gray-500'>Hello, NextJS</h1>
      <Link href='/dashboard'>Dashboard</Link>
    </main>
  )
}
```

示例：
- 动态导航
  ```
  <Link href={`/blog/${post.slug}`}>{post.title}</Link>
  ```
- 链接是否激活
  ```
  const pathname = usePathname()
  const isActive = pathname === link.href
  ```
- 滚动至锚点
  ```
  <Link href="/dashboard#settings">Settings</Link>
  // Equal
  <a href="/dashboard#settings">Settings</a>
  ```
- 禁用滚动
  ```
  // Next.js App Router 的默认行为是滚动到新路由的顶部或保持滚动位置以进行向后和向前导航
  <Link href="/dashboard" scroll={false}>Dashboard</Link>
  ```

2. useRouter Hook
允许用户以编程的形式改变路由。仅能在*客户端组件*中使用。
  ```
  'use client'
  const router = useRouter()
  router.push('/dashboard')
  ```
3. 路由与导航原理
> NextJS使用混合的方式进行路由和导航：1、*服务端*： 应用程序自动按照路由进行分割；2、*客户端*： NextJS会「预提取」和「缓存」路由。因此，当用户导航到新的路由时，浏览器不会重新加载此页面，并且仅改变路由才会重新渲染。

- 预加载 Prefetching

  在用户访问前，预加载路由。
  有两种方法实现此功能：
    - Link组件：应用程序自动预加载
    - router.prefetch()： 使用useRouter hook处理

  预加载在「静态」和「动态」路由的区别：
    - 静态路由： prefetch默认为true，整个路由会被「预加载」和「缓存」
    - 动态路由： prefetch默认为自动。仅共享布局，直到第一个loading.tsx文件预加载完毕，同时缓存30s。此措施，降低了动态路由获取的成本，我们此时展示loading ui以提供更好的交互体验。

- 缓存 Caching

  路由缓存在客户端。服务端组件的Payload和访问过的路由都将被缓存。

- 部分渲染 Partial Rendring

  部分渲染：仅在客户端上重新渲染导航时发生的路由片段的变化，并且保留所有共享段。例如：当在两个同级路由 /dashboard/settings 和 /dashboard/analytics 之间导航时，将呈现settings和analytics，并且将保留dashboard的layout。

- Soft Navigation 软导航

  React 仅渲染已更改的路由片段，同时保留 React 和浏览器状态，并且不会重新加载整个页面。

- Back and Forward Navigation 导航的前进与后退

  NextJS维护导航的前进与后退，并利用路由缓存。

### 路由分组 Route Groups
分组路由不影响URL路径的结构。

*创建*

  形如： （folderName)，folderName为路由分组的名称
  例子： (marketing)、（about)

- 分组路由之间不能包含相同的路由路径。例如：(marketing)/about/page.js 和 (shop)/about/page.js，共享/about，将导致错误；
- 跨多个根布局导航，会导致整个页面重新加载（与客户端导航相反）。例如，从使用 app/(shop)/layout.js 的 /cart 导航到使用 app/(marketing)/layout.js 的 /blog 将导致整个页面加载。

### 动态路由 Dynamic Routes

*创建*

  形如： [folderName],folderName为路由片段名称
  例子：[id], [slug]
动态路由可作为params参数，提供给layout，page，route以及generagenerateMetada函数。
```
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>
}
// route: app/blog/[slug]/page.js
// URL: /blog/a
// params: { slug: 'a' }
```

- 生成静态参数 Generating Static Params
  generateStaticParams(): 与动态路由结合使用，在构建时生成静态路由，而不是在请求时按需生成

  ```
  // route: app/blog/[slug]/page.js
  export async function generateStaticParams() {
    const posts = await fetch('https://.../posts').then((res) => res.json())
  
    return posts.map((post) => ({
      slug: post.slug,
    }))
  }
  ```

- 缓存所有片段 Cache-all Segements

  *创建*

    形如： [...floderName], folderName为路由片段名称

  例如：app/shop/[...slug]/page.js 匹配 /shop/clothes, 同时也匹配 /shop/clothes/tops, /shop/clothes/tops/t-shirts

- 可选的缓存所有片段 Optional Cache-all Segements

  *创建*

    形如： [[...floderName]], folderName为路由片段名称

  例如：app/shop/[[...slug]]/page.js 匹配 /shop/clothes, 同时也匹配 /shop/clothes/tops, /shop/clothes/tops/t-shirts 以及 /shop（注意与cache-all的区别）


### 加载UI和流式传输 Loading UI and Streaming

- Loading UI

  加载动画，用于提升用户交互体验

- Streaming

  - 传统SSR（服务端渲染），用户可以查看并发生交互的步骤：
    1. 页面所需数据均以在服务端获取
    2. 服务端渲染页面的HTML
    3. 将页面所需的HTML、CSS、JS发送给客户端
    4. 利用HTML 和 CSS 显示非交互式用户界面
    5. React使用户界面具备交互性
    这些步骤是「连续」且「阻塞」的。而且，在客户端，只有下载了页面中所有组件的代码，界面才具备交互性。

  - Streaming出场
    允许将页面的 HTML 分解为更小的块，并逐步将这些块从服务器发送到客户端。

    Streaming与 React 的组件模型配合得很好，因为每个组件都可以被视为一个块。优先级较高的组件（例如：company intrudce）或不依赖数据的组件可以先发送（例如：layout），同时，react可以更早进行处理。具有较低优先级的组件（例如：reviews）可以在获取数据后发送。

    好处：
      - 降低TTFB（ Time To First Byte， 第一个字节时间， 作用：衡量对资源的请求和响应的第一个字节开始和到达之间时间的指标 ）
      - 降低FCP（First Contentful Paint ，首次内容绘制， 作用：测量用户导航到页面后浏览器渲染第一段 DOM 内容所需的时间）
      - 降低TTI（ Time to Interactive， 完全可交互时间，作用：衡量页面达到完全可交互所需的时间）

    ```
    // 结合Suspense，启用Streaming
    import { Suspense } from 'react'
    import { PostFeed, Weather } from './Components'
    
    export default function Posts() {
      return (
        <section>
          <Suspense fallback={<p>Loading feed...</p>}>
            <PostFeed />
          </Suspense>
          <Suspense fallback={<p>Loading weather...</p>}>
            <Weather />
          </Suspense>
        </section>
      )
    }
    ```

    Streaming不会对SEO产生影响。Next.js 将等待generateMetadata 内的数据获取完成，然后再将UI 流式传输到客户端。这保证了流式响应的第一部分包含 ```<head>``` 标签


### 错误处理 Error handing
可优雅的处理嵌套路由中运行时产生的意外错误。
Error Component只能是客户端组件
```
'use client' // Error components must be Client Components
 
import { useEffect } from 'react'
 
export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}
```

Error不会捕获同级layout.tsx或者template.tsx的异常。但，父级error可捕获子节点中layout.tsx或者template.tsx的异常。处理根目录layout.tsx或者template.tsx的异常，请使用global-error.tsx。

global-error.tsx文件，需包涵```<html>```、```<body>```标签

### 并行路由 Parallel Route
并行路由允许同时或有条件地在同一布局中渲染一个或多个页面。

*创建*

  形如： @folderName

  ```
  // file structure: 
  //      app/@analytics/pages.tsx
  //      app/@team/pages.tsx
  //      app/layout.tsx

  export default function Layout(props: {
    children: React.ReactNode
    analytics: React.ReactNode
    team: React.ReactNode
  }) {
    return (
      <>
        {props.children}
        {props.team}
        {props.analytics}
      </>
    )
  }
  ```

### 路由拦截 Intercepting Routes

拦截路由允许从当前布局内应用程序的其他部分加载路由。当您想要显示路由内容而不需要用户切换到不同的上下文时，此路由范例非常有用。
