# 获取数据 Fetching Data

获取数据是任何应用的核心部分。此部分，从数据获取、缓存、刷新学习NextJS和React。

四种方法获取数据：

  - 服务端：fetch、第三方库
  - 客户端：Route handlers、第三方库（SWR、Reqct Query）
    


## 在服务端使用fetch获取数据

  NextJS扩展了Web API fetech，允许为服务器上的每个fetch请求配置缓存和刷新。

  ```
  async function getData() {
    const res = await fetch('https://api.example.com/...')
    // The return value is *not* serialized
    // You can return Date, Map, Set, etc.
  
    if (!res.ok) {
      // This will activate the closest `error.js` Error Boundary
      throw new Error('Failed to fetch data')
    }
  
    return res.json()
  }
  
  export default async function Page() {
    const data = await getData()
  
    return <main></main>
  }
  ```
  
  - 缓存数据

    默认情况下，Next.js 自动将 fetch 的返回值缓存在服务器上的 Data Cache 中。这意味着可以在构建时或请求时获取数据、缓存数据并在每个数据请求上重用。

    默认配置如下：

      ```
      // 'force-cache' is the default, and can be omitted
      fetch('https://...', { cache: 'force-cache' })
      ```
    
    使用 POST 方法的 fetch 请求也会自动缓存。若它位于使用 POST 方法的路由处理程序内，则不会被缓存。

  - 刷新数据

    刷新数据是刷新缓存，重新获取最新数据的过程。

    可通过两种方式刷新数据：

      - Time-based revalidation（基于时间的刷新）：对于不经常更改或实时性要求不高的数据，可以通过设定刷新时间，自动刷新数据

        ```
        fetch('https://...', { next: { revalidate: 3600 } })
        ```

      - On-demand revalidation（按需刷新）：根据事件（如：表单提交），手动刷新数据。可基于标签或路径的方式刷新。

        NextJS内部提供缓存标签系统：

          ```
          // 增加缓存标签
          export default async function Page() {
            const res = await fetch('https://...', { next: { tags: ['collection'] } })
            const data = await res.json()
            // ...
          }
          ```

          ```
          // app/api/revalidate/route.ts
          // 通过标签触发刷新
          import { NextRequest, NextResponse } from 'next/server'
          import { revalidateTag } from 'next/cache'
          
          // e.g a webhook to `your-website.com/api/revalidate?tag=collection&secret=<token>`
          export async function POST(request: NextRequest) {
            const secret = request.nextUrl.searchParams.get('secret')
            const tag = request.nextUrl.searchParams.get('tag')
          
            if (secret !== process.env.MY_SECRET_TOKEN) {
              return NextResponse.json({ message: 'Invalid secret' }, { status: 401 })
            }
          
            if (!tag) {
              return NextResponse.json({ message: 'Missing tag param' }, { status: 400 })
            }
          
            revalidateTag(tag)
          
            return NextResponse.json({ revalidated: true, now: Date.now() })
          }
          ```

          ```
          // app/api/revalidate/route.ts
          // 通过路径刷新
          import { NextRequest, NextResponse } from 'next/server'
          import { revalidatePath } from 'next/cache'
          
          export async function POST(request: NextRequest) {
            const path = request.nextUrl.searchParams.get('path')
          
            if (!path) {
              return NextResponse.json({ message: 'Missing path param' }, { status: 400 })
            }
          
            revalidatePath(path)
          
            return NextResponse.json({ revalidated: true, now: Date.now() })
          }
          ```
          
    - 错误处理与刷新

      如果刷新数据时抛出错误，则将继续从缓存中提供最近刷新成功的数据。在下一个后续请求中，Next.js 将重新刷新数据。

  - 控制不缓存配置参数

    1. cache: 'no-store'， 添加至fetch request中

      ```
      fetch('https://...', { cache: 'no-store' })
      ```

    2. revalidate: 0， 添加至fetch request中
    3. 在路由处理函数中使用fetch POST
    4. 修改cookie或header
    5. 在路由处理函数中使用const dynamic = 'force-dynamic'
    6. fetchCache 路由片段选项默认配置为跳过缓存
    7. fetch request 使用 Authorization 或 Cookie，并且组件树中其上方有一个未缓存的请求。


## 在服务端使用第三方库获取数据

  数据是否被缓存，取决于路由是静态渲染还是动态渲染。若使用静态渲染，则会被缓存，反之，则不缓存

  ```
  // utils/get-item.ts
  import { cache } from 'react'
 
  export const revalidate = 3600 // revalidate the data at most every hour
  
  export const getItem = cache(async (id: string) => {
    const item = await db.item.findUnique({ id })
    return item
  })
  ```

  ```
  // 缓存数据
  // app/item/layout.tsx
  import { getItem } from '@/utils/get-item'
 
  export default async function Layout({
    params: { id },
  }: {
    params: { id: string }
  }) {
    const item = await getItem(id)
    // ...
  }
  ```

  ```
  // 不缓存数据
  // app/item/[id]/page.tsx
  import { getItem } from '@/utils/get-item'
 
  export default async function Page({
    params: { id },
  }: {
    params: { id: string }
  }) {
    const item = await getItem(id)
    // ...
  }
  ```
